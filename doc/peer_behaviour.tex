\section{Peer Behaviour}

The system consists of three types of agent: Super Peers, Ordinary Peers and a
single Host Cache.  The Host Cache is implemented as an agent in order to unify
the connection behaviour between elements of the system.  In other words, peers
can connect to the Host Cache using the same mechanisms that are required to
connect to each other.

It can be helpful to think of the identity of an agent as defined by the kinds
of behaviours it can support. What we mean here by a behaviour is the ability to
respond in some way to a particular situation or event.  Some behaviours
continually monitor the state of the agent in the network, whereas others
are triggered by incoming messages from other agents.

The process of specifying and identifying different messages is explained in
another section.

Super Peers and Ordinary Peers implement a common set of behaviours. For
the sake of simplicity, the designation of peers into Super and Ordinary sets
will occur during initialization of the system.

\subsection{Host Cache}

The Host Cache is the entry-point for the network with two responsibilities.
Firstly, to maintain a list of connected peers. Secondly, to supply peers with a
list of Super Peers which they can attempt to connect to

Theses behaviours can be summarised by the following piece of pseudocode. It
will run when the Host Cache receives a message identified as `Neighbours
Request'.

\subsubsection{Receive `Neighbours Request`}

\begin{algorithm}[H]
  \SetKwInOut{Input}{input}
  \SetKwFunction{ReplyFn}{reply}
  \Input{Message Name: `Neighbours Request' \\ Message Sender: $peer$}
  \KwData{$peerList$: A hash of peers with value true if peer is super}
  \If{peer list doesn't contain $peer$}{
    add $peer$ to $peerList$\;
  }
  \For{$peer \in peerList$}{
    \If{$peerList[peer] = true$}{
      $neighbours \leftarrow peer$\;
    }
  }
  \ReplyFn{`Neighbours Response', neighbours}
\caption{Receive `Neighbours Request'}
\end{algorithm}

\subsection{Peers}

Here we will explain the different types of behaviours implemented by both Super
and Ordinary Peers. Some of these behaviours are shared between all peers, but
their effects will differ depending on whether the peer is Super or Ordinary.
This is a design decision which compromises simplicity of the described
behaviours with simplicity of the system as a whole.\footnote{The idea is
analogous to the contradiction between two rules of software engineering: The
Law of Demeter which aims to minimise method chaining, and the idea of class
cohesion which gives an object well-bounded behaviour.}

This behaviour is responsible for maintaining a list of Super Peers that the
peer can connect to.  One consequence of this design is that the peers will
always have a list of potential peers to connect to, even when they already have
their maximum number of connected peers. Additionally, $knownPeers \cap
connectedPeers \neq \emptyset$.

\begin{algorithm}[H]
  \SetKwInOut{Input}{input}
  \SetKwFunction{SendFn}{send}
  \KwData{$knownPeers$: A list of neighbours known but not connected to the
  peer}
  \KwData{$hostCache$: Address of the Host Cache}
  \If{$knownPeers = \emptyset$}{
    \SendFn{hostCache, `Neighbours Request'}
  }
\caption{Send `Neighbours Request'}
\end{algorithm}

\begin{algorithm}[H]
  \SetKwInOut{Input}{input}
  \Input{Message Name: `Neighbours Response' \\ Neighbours: $peers$ \\ Message
  Sender: $sender$}
  \KwData{$knownPeers$: A list of neighbours known but not connected to the
  peer}
  \KwData{$hostCache$: Address of the Host Cache}
  \If{$sender = hostCache$}{
    $knownPeers \cap  peers$\;
  }
\caption{Receive `Neighbours Response'}
\end{algorithm}

\begin{algorithm}[H]
  \SetKwInOut{Input}{input}
  \SetKwFunction{SendFn}{send}
  \SetKwFunction{LenFn}{length}
  \KwData{$knownPeers$: A list of neighbours known but not connected to the
  peer}
  \KwData{$connectPendingPeers$: Peers that have been sent a connection request}
  \KwData{$minPeers$: Required number of connected peers.}
  \If{$knownPeers \neq \emptyset $ {and} \LenFn{$connectPendingPeers \cap
  connectedPeers$}$ < minPeers$}{
    \SendFn{$ \exists p \in knownPeers$, `Connect Request'}
  }
\caption{Send `Connect Request'}
\end{algorithm}









\subsection{Message Definitions}

\begin{itemize}
  \item{Neighbours Request}
  \item{Neighbours Response}
  \item{Search Request}
  \item{Search Response}
  \item{File Request}
  \item{File Response}
  \item{File List}
  \item{Connect Request}
  \item{Connect Response}
\end{itemize}








